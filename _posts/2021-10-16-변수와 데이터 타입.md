---
layout: post
title: "자바스크립트 변수와 데이터타입"
author: Minsun
categories: [Development]
tags: [JavaScript]
image: "assets/images/deep-dive.png"
beforetoc: ""
toc: true
---

### 변수
컴퓨터는 모든 데이터를 2진수로 받고 메모리에 저장하게 되는데 변수는 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙여진 이름이다.

### 변수의 선언
- 변수의 선언단계<br />
변수의 선언단계에선 값을 저장할 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결하여 값이 저장 될 수 있도록 준비하는 과정이 이루어진다. 이때 **확보된 공간에 자바스크립트 엔진은 `undefined` 를 할당하여 초기화한다.** 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전의 다른 애플리케이션이 사용했던 값(garbage value)이 값을 할당하지 않는 상태에서 바로 변수를 참조하게 되면 나올 수 있기때문에 초기화해주는 것이 안전하다.

- 호이스팅

```jsx
console.log(hi); //undefined
var hi = 'hello';

//const, let 키워드를 사용하여 변수를 선언한 경우 참조에러가 발생한다.
```

변수를 선언하기 직전에 변수를 참조하여도 참조에러가 발생하지 않고 undefined로 출력되는 이유는 변수 선언이 코드가 실행되는 런타임 시점이 아니라 그 이전단계, 소스코드의 평가 과정에서 실행되기 때문이다. **자바스크립트 엔진은 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아 먼저 실행하기 때문에 어디에 위치하던지 상관없이 참조가 가능한 것이다.** 이러한 자바스크립트의 특징을 소스코드 내에 모든 식별자는 코드 선두에 끌어올려진 것처럼 동작하는 것을 호이스팅이라한다.<br />
✨값의 할당은 런타임 시점에 일어난다.

### 값의 재할당

변수에 새로운 값을 재할당하게 되면 이전의 값이 위치해 있던 메모리 공간을 지우고 새로운 값을 저장하는게 아니라 새로운 메모리 공간을 확보하여 그 공간에 새로운 값을 저장하게 된다. 어떠한 식별자와 연결되어 있지 않는 값들은 가비지 콜렉터에 의해 메모리에서 자동으로 해제된다. (메모리 누수를 방지하기 위해서)

### 데이터 타입의 필요성

자바스크립트의 모든 값은 데이터 종류로 분류된다. <br />
- 값은 메모리에 저장되고 참조할 수 있어야 하기 때문에 먼저 메모리에 확보해야할 공간의 크기를 결정해야한다. **자바스크립트 엔진은 변수에 할당된 값의 데이터 타입에 따라 메모리 공간을 확보한다.**

### 동적타이핑

자바스크립트는 값에 따라 데이터 타입이 결정되기 때문에 값에 따라 변수의 타입이 언제든지 변할 수 있다. 이러한 특징을 동적 타이핑이라고 한다.

### 원시 값과 객체 비교

- 원시 값<br />
    원시 값은 변경 불가능한 값(immutable value)이다. 변경 불가능 하다는 것은 값 자체를 변경할 수 없다는 것이지 변수의 값을 변경할 수 없다는 아니다. 변수는 언제든지 재할당을 통해 값 변경이 가능하다. (`const` 키워드로 생성하는 변수 제외) 원시 값은 값 자체 변경이 안되기 때문에 변수에 새로운 값 재할당이 일어나면 새로운 메모리 공간을 확보하고 그곳에 값을 저장하게 되는데 이러한 특성을 **불변성**이라고한다.<br />
    문자열도 원시값이기 때문에 변경불가능하다. 문자열은 유사배열 객체이기 때문에 인덱스를 사용하여 각 문자에 접근이 가능한데 인덱스로 접근한 값에 새로운 값을 할당하여도 반영되지 않는다. **원시 값은 읽기 전용이기 때문에 값 자체 변경이 불가능하기 때문이다.**
    
- 값에 의한 전달<br />
    변수에 원시 값을 가진 변수를 할당하게 되면 할당 받는 변수는 할당 되는 변수의 원시값이 복사되어 전달된다. 이를 값에 의한 전달이라한다. **두 변수는 같은 값을 가졌지만 메모리 공간에선 각각 다른 곳에 저장된 별개의 값이다.**
    
    ```jsx
    //각각 다른 별개의 메모리 공간에 저장된 값이기 때문에
    //score 값이 변경되더라도 copy에는 영향을 끼치지 않는다.
    var score = 80;
    var copy = score
    score = 100
    console.log(copy)
    ```
    
- 객체<br />
    객체는 원시값과 달리 미리 메모리 크기를 결정할 수 없다. <br />
    객체 타입의 값은 변경 가능한 값(mutable value)이다. 원시값은 메모리 주소를 통해 바로 값에 접근이 가능하지만 **객체는 메모리 주소를 통해 생성된 객체가 저장된 메모리 주소를 알 수 있는 참조값에 접근할 수 있다.** 객체는 변경가능한 값이기 때문에 재할당 없이 직접 변경이 가능하다. 재할당이 이루어지지 않았기 때문에 객체가 할당된 변수의 참조값 또한 변경되지 않는다.
    
- 참조에 의한 전달<br />
    객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 전달되는데 이를 참고에 의한 전달이라한다. 그렇게 되면 각각 다른 메모리 주소에 동일한 참조값을 가리키게 되는데 이는 서로 값이 변경될때 영향을 끼치는 부작용을 발생시킨다.